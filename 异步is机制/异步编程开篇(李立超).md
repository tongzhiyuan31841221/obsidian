在计算机的世界中程序有同步和异步两种不同的运行方式。通常情况下在其他的语言中我们所编写的代码都是同步运行的，所谓的同步运行也就是代码一行一行按顺序执行，一行执行完才会执行下一行。像下边这样一个操作，就是非常典型的同步代码：

```js
function sum(a, b){
    return a + b
}

console.log("第一行打印")
let result = sum(123, 456)
console.log(result)
console.log("第二行打印")
```

同步代码的逻辑清晰、结构简单、容易理解。同步就好像我们在按照顺序做事情：先刷牙，再洗脸，然后洗头发，接着抹擦脸油，最后吹头发。总之一件事干完才去干下一件事。同步看上去十分合理，但是真正操作起来却不总是那么的尽如人意。

## 阻塞

同步的最大问题是阻塞，所谓阻塞就是一段代码不执行完毕其后的所有代码也不会执行。比如上述的案例中，如果sum()函数执行速度比较慢，由于我们编写的是同步代码，所以在sum()执行完之前其后所有代码都不会执行，也就是它会阻塞后边代码的执行。像是这样：

```js
function sum(a, b){
    let begin = Date.now()
    while(Date.now() - begin < 10000){

    }
    return a + b
}

console.log("第一行打印")
let result = sum(123, 456)
console.log(result)
console.log("第二行打印")
```

上例中sum()执行时会停顿10秒，10秒以后才会返回结果，由于是同步执行的代码，所以sum()会阻塞其后所有代码的执行，导致整个程序的执行速度极差。

想象这样一个场景：如果人是同步运行的会怎么样呢？假如一个人必须要做完一件事才能做下一件事情，会是什么样子的？

昨天我买了一管牙膏，快递还没到，可是我早上起来的第一件事就是刷牙，然后洗脸等一系列的事情依次进行。由于我是同步运行的，如果不刷牙其他的事情都无法进行，于是出现了这样一个场景，一大清早，我站在镜子前手里举着牙刷发呆，我在干嘛？等着牙膏来了，我好去刷牙……没有牙膏这件事导致我无法刷牙，而刷牙不能完成后续工作我也无法继续，换句话说，刷牙阻塞了我的其他操作。
## 异步--回调函数
回调函数[[后盾人的一些补充#异步使用回调函数的形式进行图片加载]]
在程序中也是如此，程序中有些代码的执行速度很快，比如：打印一个内容、接收一个请求、发送一个响应等这些都是简单且快速的操作，但有些操作却很慢，比如：读写硬盘中的文件（I/O操作）。显然我们是不希望那些运行很慢的操作阻塞到那些运行快的操作的。那要如何处理呢？

对于其他的编程语言，如java，它的处理方式简单且粗暴，即多线程。线程是计算机中运算的执行者，我们代码需要线程来执行，它是一个干活的人。在java中，如果遇到阻塞的问题，我们可以多开几个线程。你不是不希望读取文件影响到其他操作吗？ok，我开一个线程读取文件，另一个线程去做其他操作，这样做是完全可行的，且显得非常高级。就好像我们没有牙膏刷牙了，我们怎么办呢？咔咔咔！影分身之术，一个分身等牙膏，一个分身去洗脸洗头。

但是对于Node.js来说，它本身就是单线程的，没有创建多个线程的能力（就像人不能影分身一样）。那它要怎么办呢？答案就是 —— 异步！在node中，当我们遇到这种比较慢的操作时，都会采用异步的操作。比如，当我们希望去读取一个较大的文件时，node可以先将指令发送给计算机，然后由计算机去读取文件，此时node的线程不是等待计算机数据返回，而是继续向下执行其他的操作，何时去获取计算机读取到的数据呢？不急，等数据返回了我们再去读取，这样既不影响其他操作也可以正常的读取到计算机返回的数据！上边的代码我们便可以这样修改：
```js
function sum(a, b){
    setTimeout(()=>{
        return a + b
    }, 10000)
}

console.log("第一行打印")
let result = sum(123, 456)
console.log(result)
console.log("第二行打印")
```
但与此同时也产生了一个问题，函数确实不会阻塞后续代码的执行了，但是由于函数的返回值设置到了setTimeout的回调函数中调用sum时便无法获取到函数的计算结果了，此时我们得到的结果是undefined。这也是异步的一个特点，异步代码的执行结果无法通过返回值获得，返回值只能用来获取同步代码的执行结果。那么如何获取异步代码的执行结果呢？答案只有一个——回调函数，异步代码通常都需要一个回调函数作为参数，当异步代码执行完毕取得结果时便可以将结果作为回调函数的参数进行传递，这样我们便可以在回调函数中来读取结果，并完成后续操作了，像是这样：
```js
function sum(a, b, cb){
    setTimeout(()=>{
        cb(a + b)
    }, 10000)
}

console.log("第一行打印")
sum(123, 456, result => {
    console.log(result)
})
console.log("第二行打印")
```
## 问题

异步代码最大的问题就是回调函数。由于是异步执行，异步函数无法直接通过返回值来返回执行结果，要想取得结果必须通过回调函数。这也就带来了一个问题，如果我们有两个异步操作需要先后执行，一个异步操作依赖于上一个异步操作的执行结果那要怎么办呢？简单，只需要在第一个异步操作的回调函数中调用第二个异步操作，像是这样：

```js
function sum(a, b, cb){
    setTimeout(()=>{
        cb(a + b)
    }, 10000)
}

sum(123, 456, result => {
    sum(result, 777, result => {
        console.log(result)
    })
})
```

上例中，调用了两次sum，第一次调用计算了123和456的和，第二次调用是求第一次的运算结果和456的和。由于异步函数的结果只能在回调函数中访问，所以我们只能在回调函数中第二次调用sum。当然，如果事情仅仅是这样其实还好。

现在假设我需要连续调用4个异步函数，且后一个要依赖于前一个的运算结果，也许会是这样的：[[后盾人的一些补充#文件加载]]

```js
function sum(a, b, cb){
    setTimeout(()=>{
        cb(a + b)
    }, 10000)
}

sum(123, 456, result => {
    sum(result, 777, result => {
        sum(result, 888, result => {
            sum(result, 999, result => {
                console.log(result)
            })
        })
    })
})
```

这样一来我们就见识到了传说中的“回调地狱”，又名“死亡金字塔”。这还只是4次，现实的代码可能比这个还要再复杂一些。比如，某个功能需要用到三个不同异步函数返回的结果。